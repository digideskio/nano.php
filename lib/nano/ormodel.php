<?php

/* A base class for database-driven models using a simple ORM pattern.
   This is more restricted in pattern than the standard DBModel, as it
   can represent only a single table in the database. That said, it's
   pretty much the most common pattern, so if it fits, use it.
   It requires the use of a DBItem subclass. 
 */

load_core('dbmodel');  // Our parent class.
load_core('models');   // Should be loaded already, but just in case.

class ORModelException extends Exception {}

abstract class ORModel 
  extends DBModel 
  implements Iterator
{
  protected $all_rows;      // A cache of all rows.
  protected $current_row;   // The currently iterated item.
  protected $table;          // Our database table.
  protected $childclass;     // The class name for our children.
                             // Must already be loaded, and must extend the
                             // DBItem parent class. If you don't specify
                             // this, it defaults to a raw DBItem.
  protected $primary_key;    // The primary key on the database table.
                             // Defaults to 'id' if not specified.

  protected $sql;            // The query to be used for iteration.
  protected $bind;           // The binding rules for your query.

  public function name ()
  {
    return get_model_id($this);
  }

  public function __construct ($opts=array())
  {
    parent::__construct($opts);
    if (isset($opts['table']))
      $this->table = $opts['table'];
    else
      $this->table = $this->name();
    if (isset($opts['childclass']))
      $this->childclass = $opts['childclass'];
    else
    { load_core('dbitem');
      $this->childclass = 'DBItem';
    }
    if (isset($opts['primary_key']))
      $this->primary_key = $opts['primary_key'];
    else
      $this->primary_key = 'id';
    // By default we our iterator returns everything.
    $this->setQuery();
  }

  // Wrap the results of fetch() in a nice object.
  // If the hash is not set, or is false it returns null.
  protected function wrapRow ($rowhash)
  { if ($rowhash)
    {
      $class = $this->childclass;
      $object = new $class($rowhash, $this, $this->table, $this->primary_key);
      return $object;
    }
    else
      return null;
  }

  // Get a row based on the value of a field
  public function getRowByField ($field, $value, $ashash=false)
  {
    $sql = "SELECT * FROM {$this->table} WHERE $field = :value LIMIT 1";
    $query = $this->query($sql);
    $query->execute(array(':value'=>$value));
    $row = $query->fetch();
    if ($ashash)
      return $row;
    else
      return $this->wrapRow($row);
  }

  // Get a row based on the value of the primary key, here called Id.
  public function getRowById ($id)
  {
    return $this->getRowByField($this->primary_key, $id);
  }

  // Make wrappers for this in your classes.
  public function setQuery ($query=null, $bind=array())
  { // Set the SQL itself.
    if (isset($query))
      $this->sql = $query;
    else
      $this->sql = "SELECT * FROM {$this->table}";

    // And set the array values.
    $this->bind = $bind;
  }

  // Insert a new row. Note this does no checking to ensure
  // the specified fields are valid, so wrap this in your own
  // classes with more specific versions. It's also not recommended
  // that you include the primary key field, as it should be auto
  // generated by the database. To this end, by default we disallow
  // the primary key field. As the output of an insert is not consistent
  // we just return the query object, if you're at all interested.
  public function newRow ($row, $allowpk=false)
  {
    $pk = $this->primary_key;
    $sql = "INSERT INTO {$this->table} ";
    $fieldnames = '(';
    $fieldvals  = '(';
    $fielddata  = array();
    $keys = array_keys($row);
    $kc   = count($row);
    for ($i=0; $i < $kc; $i++)
    {
      $key = $keys[$i];
      if ($key == $pk && !$allowpk) continue; // Skip primary key.
      $fk = ":$key";
      $fieldnames .= $key;
      $fieldvals  .= $fk;
      $fielddata[$fk] = $row[$key];
      if ($i != $kc - 1)
      {
        $fieldnames .= ', ';
        $fieldvals  .= ', ';
      }
    }
    $fieldnames .= ')';
    $fieldvals  .= ')';
    $sql .= "$fieldnames VALUES $fieldvals";
    $query = $this->query($sql);
    $query->execute($fielddata);
    return $query;
  }

  // Let's perform a query against the database.
  // This is only applicable if we want to iterate against
  // the entire table.
  public function rewind () { 
    $query = $this->query($this->sql);
    $query->execute($this->bind);
    $this->all_rows = $query;
    $this->next();
  }
  public function next () { 
    $this->current_row = $this->all_rows->fetch();
  }
  public function current () { 
    return $this->wrapRow($this->current_row);
  }
  public function key () {
    $pk = $this->primary_key;
    return $this->current_row[$pk];
  }
  public function valid () {
    if ($this->current_row)
      return true;
    return false;
  }

}
