<?php

/* A base class for database-driven models.
   It wraps around the PDO library, and provides some very simplistic
   ORM capabilities. You don't have to use them, but if you want them
   they are there. The built-in ORM represents a single table. 
   For more advanced methods such a multi-table support, you can use the
   query() method directly and write methods in your extended class.
 */

class DBModelException extends Exception {}

abstract class DBModel implements Iterator
{
  protected $db;             // Our database object.

  protected $all_rows;       // A cache of all rows.
  protected $current_row;    // The currently iterated item.
  protected $table;          // Our database table.
  protected $childclass;     // The class name for our children.
                             // Must already be loaded, and must extend the
                             // DBItem parent class. If you don't specify
                             // this, it defaults to a raw DBItem.
  protected $primary_key;    // The primary key on the database table.
                             // Defaults to 'id' if not specified.

  protected $sql;            // The query to be used for iteration.
  protected $bind;           // The binding rules for your query.

  public function name ()
  {
    $nano = get_nano_instance();
    return $nano->models->id($this);
  }

  public function __construct ($opts=array())
  {
    if (!isset($opts['dsn']))
      throw new DBModelException("Must have a database DSN");
    if (isset($opts['user']) && isset($opts['pass']))
      $this->db = new PDO($opts['dsn'], $opts['user'], $opts['pass']);
    else
      $this->db = new PDO($opts['dsn']);

    if (isset($opts['table']))
      $this->table = $opts['table'];
    else
      $this->table = $this->name();
    if (isset($opts['childclass']))
      $this->childclass = $opts['childclass'];
    else
    { $nano = get_nano_instance();
      $nano->loadBase('dbitem');
      $this->childclass = 'DBItem';
    }
    if (isset($opts['primary_key']))
      $this->primary_key = $opts['primary_key'];
    else
      $this->primary_key = 'id';
    // By default we our iterator returns everything.
    $this->setQuery();

  }

  // Create a prepared statement, and set its default fetch style.
  public function query ($statement, $assoc=True)
  {
    $query = $this->db->prepare($statement);
    if ($assoc)
      $query->setFetchMode(PDO::FETCH_ASSOC);
    else
      $query->setFetchMode(PDO::FETCH_NUM);
    return $query;
  }

  // Wrap the results of fetch() in a nice object.
  // If the hash is not set, or is false it returns null.
  public function wrapRow ($rowhash)
  { if ($rowhash)
    {
      $class = $this->childclass;
      $object = new $class($rowhash, $this, $this->table, $this->primary_key);
      return $object;
    }
    else
      return null;
  }

  // Get a row based on the value of a field
  public function getRowByField ($field, $value, $ashash=false)
  {
    $sql = "SELECT * FROM {$this->table} WHERE $field = :value LIMIT 1";
    $query = $this->query($sql);
    $query->execute(array(':value'=>$value));
    $row = $query->fetch();
    if ($ashash)
      return $row;
    else
      return $this->wrapRow($row);
  }

  // Get a row based on the value of the primary key, here called Id.
  public function getRowById ($id, $ashash=false)
  {
    return $this->getRowByField($this->primary_key, $id, $ashash);
  }

  // Make wrappers for this in your classes.
  public function setQuery ($query=null, $bind=array())
  { // Set the SQL itself.
    if (isset($query))
      $this->sql = $query;
    else
      $this->sql = "SELECT * FROM {$this->table}";

    // And set the array values.
    $this->bind = $bind;
  }

  // Insert a new row. Note this does no checking to ensure
  // the specified fields are valid, so wrap this in your own
  // classes with more specific versions. It's also not recommended
  // that you include the primary key field, as it should be auto
  // generated by the database. To this end, by default we disallow
  // the primary key field. As the output of an insert is not consistent
  // we just return the query object, if you're at all interested.
  public function newRow ($row, $allowpk=false)
  {
    $pk = $this->primary_key;
    $sql = "INSERT INTO {$this->table} ";
    $fieldnames = '(';
    $fieldvals  = '(';
    $fielddata  = array();
    $keys = array_keys($row);
    $kc   = count($row);
    for ($i=0; $i < $kc; $i++)
    {
      $key = $keys[$i];
      if ($key == $pk && !$allowpk) continue; // Skip primary key.
      $fk = ":$key";
      $fieldnames .= $key;
      $fieldvals  .= $fk;
      $fielddata[$fk] = $row[$key];
      if ($i != $kc - 1)
      {
        $fieldnames .= ', ';
        $fieldvals  .= ', ';
      }
    }
    $fieldnames .= ')';
    $fieldvals  .= ')';
    $sql .= "$fieldnames VALUES $fieldvals";
    $query = $this->query($sql);
    $query->execute($fielddata);
    return $query;
  }

  // Let's perform a query against the database.
  // This is only applicable if we want to iterate against
  // the entire table.
  public function rewind () { 
    $query = $this->query($this->sql);
    $query->execute($this->bind);
    $this->all_rows = $query;
    $this->next();
  }
  public function next () { 
    $this->current_row = $this->all_rows->fetch();
  }
  public function current () { 
    return $this->wrapRow($this->current_row);
  }
  public function key () {
    $pk = $this->primary_key;
    return $this->current_row[$pk];
  }
  public function valid () {
    if ($this->current_row)
      return true;
    return false;
  }

}

