<?php

namespace Nano4\Utils\HTML;

/**
 * The original classic menu generator.
 *
 * It's still available for use, but the new Router-based menu is better.
 */

class RouterMenu
{
  protected $parent;

  public function __construct ($opts=[])
  {
    if (isset($opts['parent']))
      $this->parent = $opts['parent'];
  }

  /**
   * Build a menu.
   *
   * Given some information and a menu definition, this will
   * generate an HTML menu using a specific layout.
   *
   * @param Array  $menu      The menu definition.
   * @param Object $context   The RouteContext object for the request.
   * @param Array  $opts      Options to change the behavior.
   *
   * @return SimpleXMLElement  An HTML structure representing the menu.
   *
   * Menu Formats
   *
   * There are a few accepted menu formats. We detect them
   * automatically as we build the menu.
   *
   * If you use a flat (non-associative) array, then you will
   * need to supply the 'route' and 'name' parameters within the
   * item definition (which is an associative array).
   * 
   * Otherwise, if the menu itself is an associate array, the key
   * will be used as the 'url' or 'name' tags if one or both of
   * them is missing, but only if it is a string.
   *
   * Options
   *
   *   root        A SimpleXMLElement object, or an HTML string.
   *               This represents the menu root object.
   *               Default: <div class="menu" />
   *
   *   itemel      If specified, menu items will be wrapped in this container,
   *               and any applicable CSS classes will be applied to it.
   *               If not specified, items are added as <a/> tags directly.
   *
   *   show        A list of show rules. Show rules can be applied to menu
   *               items, and can be closures or callables that return true
   *               or false, or can be a value that must match in the menu
   *               item definition.
   *
   *   classname   The class name for the "current" menu item.
   *
   *   builders    Menu items that are actually generated by a closure or
   *               callable that is passed the menu XML object.
   *
   *   handlers    Menu items can be passed to closures/callables that will
   *               can apply classes or perform other manipulations.
   *
   */
  public function buildMenu ($menu, $context, $opts=[])
  { 
    // The root element.
    if (isset($opts['root']))
    {
      $container = $opts['root'];
      if (is_string($container))
      {
        $container = new \SimpleXMLElement($container);
      }
    }
    else
    {
      $container = new \SimpleXMLElement('<div class="menu" />');
    }

    // A wrapper element.
    $item_el = isset($opts['itemel']) ? strtolower($opts['itemel']) : Null;

    // Custom rules to filter out certain menu items.
    $show_rules = isset($opts['show']) ? $opts['show'] : [];

    // Custom rules to build the items rather than using the built-in logic.
    $build_rules = isset($opts['builders']) ? $opts['builders'] : [];

    // Custom rules to apply styles or other modifications.
    $post_rules = isset($opts['handlers']) ? $opts['handlers'] : [];

    // Label element name.
    $label_el = isset($opts['label_class']) ? $opts['label_class'] : 'span';

    // Current class
    $current_class = isset($opts['current_class']) ? $opts['current_class'] :
      'current';

    // Okay, let's do this.
    foreach ($menu as $key => $def)
    {
      // Let's see if there are any filters that apply.
      $filtered = False;
      foreach ($show_rules as $rkey => $rule)
      { 
        // We only perform the checks on defs that have the rule.
        if (isset($def[$rkey]))
        {
          if (is_callable($rule))
          { // Our closure will return True or False.
            if (!$rule($def, $key, $context))
            { // If we get False, we skip this menu item.
              $filtered = True;
              break;
            }
          }
          else
          { // We check to see if the values match up.
            if ($def[$rkey] != $rule)
            { // Our show rule did not match, skip this menu item.
              $filtered = True;
              break;
            }
          }
        }
      }
      if ($filtered) 
      { // One of the show rules did not match, skip this item.
        continue; 
      }

      // Next, deal with custom builders.
      $built = False;
      foreach ($build_rules as $rkey => $rule)
      {
        if (isset($def[$rkey]))
        {
          if (is_callable($rule))
          {
            $item = $rule($def, $key, $context, $container);
          }
          else
          {
            $text = $rule;
            if (isset($this->parent, $this->parent->translate))
            {
              $text = $this->parent->translate[$text];
            }
          }
          $item = $container->addChild($label_class, $text);
        }
        $built = True;
      }

      if (!$built)
      {
        if (isset($def['route']))
        {
          $mroute = $def['route'];
        }
        elseif (isset($def['url']))
        {
          $url   = $def['url'];
          $mroute = Null;
        }
        elseif (is_string($key))
        {
          $mroute = $key;
        }
        else
        { // skip it.
          continue;
        }

        $current = False;
        if (isset($mroute))
        {
          $router = $context->router;
          $croute = $context->route;
          $url = 
            $router->build($mroute, $context->path_params, ['strict'=>False]);

          if (is_null($url))
          {
            $url = '#';
          }

          if ($croute->name == $mroute)
            $current = True;
        }

        // Get our item name/label.
        if (isset($def['name']))
        {
          $name = $def['name'];
        }
        elseif (is_string($key))
        {
          $name = $key;
        }
        else
        {
          continue;
        }

        // Now, if we're using a translation object, translate.
        // We're using the ArrayAccess interface to the translate object.
        if (isset($this->parent, $this->parent->translate))
        {
          $name = $this->parent->translate[$name];
        }

        if (isset($item_el) && $item_el != 'a')
        { // We're using a custom container. We put an <a/> within it.
          $item = $container->addChild($item_el);
          $link = $item->addChild('a', $name);
          $link->addAttribute('href',  $url);
        }
        else
        { // We're using a raw <a/> tag (my preference.)
          $item = $container->addChild('a', $name);
          $item->addAttribute('href', $url);
        }

        // Add the current class if applicable.
        if ($current)
        {
          $item->addAttribute('class', $current_class);
        }
      }

      // Now deal with post-build handlers.
      foreach ($post_rules as $rkey => $rule)
      {
        if (isset($def[$rkey]))
        {
          if (is_callable($rule))
          {
            $rule($def, $key, $context, $item);
          }
        }
      }
    }

    // One last sanity check.
    if ($container->count() == 0)
    {
      $container->addChild('span', '&nbsp;');
    }

    return $container;
  }

}
